<!DOCTYPE html>
<html lang="en">
	<head>
		<title>three.js webgl - loaders - OBJ loader</title>
		<meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">
		<link type="text/css" rel="stylesheet" href="main.css">
	</head>

	<body>
		<script type="importmap">
			{
				"imports": {
					"three": "../build/three.module.js",
					"three/addons/": "./jsm/"
				}
			}
		</script>

		<script type="module">

			import * as THREE from 'three';

			import {Â OrbitControls } from 'three/addons/controls/OrbitControls.js';
			import { RGBELoader } from 'three/addons/loaders/RGBELoader.js';
			import { GLTFLoader } from 'three/addons/loaders/GLTFLoader.js';
			import { TessellateModifier } from 'three/addons/modifiers/TessellateModifier.js';


			// Post Processing
			import { EffectComposer } from 'three/addons/postprocessing/EffectComposer.js';
			import { RenderPass } from 'three/addons/postprocessing/RenderPass.js';
			import { SAOPass } from 'three/addons/postprocessing/SAOPass.js';
			import { OutputPass } from 'three/addons/postprocessing/OutputPass.js';
			
			// Gui
			import { GUI } from 'three/addons/libs/lil-gui.module.min.js';

			// Save/load files/cookies
			import { saveAs } from 'file-saver';
			import {  gui_map } from './gui_defaults.js';
			import Cookies from 'js-cookie';

			/////////////////////////////////
			// get material attribute data //
			/////////////////////////////////

			let mat_attrs,  cookie_mat_attrs;			
			// Try to retrieve cookie dictionary
			try {
				 cookie_mat_attrs = JSON.parse(Cookies.get("material_attributes"));
			}catch (error) {
				console.log("Cookies have not been saved for material_attributes, they will not be loaded");
			}
			// If dictionary is valid use it, otherwise use the one from gui_defaults.js
			if ( cookie_mat_attrs instanceof Object) {
				mat_attrs =  cookie_mat_attrs;
				console.log("Cookies have been saved for material_attributes, now loading")

			}else{
				mat_attrs = gui_map;
			}

			var camera, scene, renderer ;
			var geometry, material, mesh, all_models, gltf_meshes;

			//ssao
			let composer, renderPass, saoPass,container, stats, hemi_light, dir_light;
			let screen_mat, back_mat, antenna_mat, glass_mat, lens_mat, shiny_black_mat, tex_metal_mat, flash_cover_mat, dir_tex_metal_mat, metal_mat, grey_matte_mat;
			let all_meshes = [];
			let all_mats = [];
			let all_mat_names = [
									"screen_mat",
									"back_mat", 
									"antenna_mat",
									"glass_mat",
									"lens_mat",
									"shiny_black_mat",
									"tex_metal_mat",
									"flash_cover_mat",
									"dir_tex_metal_mat",
									"metal_mat",
									"grey_matte_mat"
								];

			let phone_color_mat_names = [
									"back", 

									"antenna",
									"dir_tex_metal",
									"tex_metal",

								  ];
			let phone_color_mats = [];

			let dir_metal_mat_names = [
										"tex_metal",
										"dir_tex_metal",
									  ];
			let dir_metal_mats = [];

			const dummy_mat = new THREE.MeshPhysicalMaterial();

			// eval('var test_attr;');
			let screen_tab,
				antenna_tab,
				glass_tab,
				lens_tab,
				shiny_black_tab,
				tex_metal_tab,
				flash_cover_tab,
				dir_tex_metal_tab,
				metal_tab,
				grey_matte_tab

			let gui_tabs= {
							"screen" : screen_tab,
							"antenna" : antenna_tab,
							"glass" : glass_tab,
							"lens" : lens_tab,
							"shiny_black" : shiny_black_tab,
							"tex_metal" : tex_metal_tab,
							"flash_cover" : flash_cover_tab,
							"dir_tex_metal" : dir_tex_metal_tab,
							"metal" : metal_tab,
							"grey_matte" : grey_matte_tab,
							}

			let mesh_names =[
							"screen",
							"antenna",
							"glass",
							"lens",
							"shiny_black",
							"tex_metal",
							"flash_cover",
							"dir_tex_metal",
							"metal",
							"grey_matte"
							]

			let mesh_mat_dict = {
								"screen" : dummy_mat,
								"antenna" : dummy_mat,
								"glass" : dummy_mat,
								"lens" : dummy_mat,
								"shiny_black" : dummy_mat,
								"tex_metal" : dummy_mat,
								"flash_cover" : dummy_mat,
								"dir_tex_metal" : dummy_mat,
								"metal" : dummy_mat,
								"grey_matte" : dummy_mat,
								}



			const old_params = {
				color: 0xffffff,
				phone_color: 0x8abd82,

				dir_metalness:1,
				dir_roughness:.5,

				metal_color: 0xc0c0c0,
				metal_metalness:1,
				metal_roughness:.5,


				back_transm: 1,
				back_roughness: 0,
				back_ior: 1.5,
				back_thickness: 0.01,

				glass_color:0xc0c0c0,
				glass_transm: 0,

				back_transmission: 1,
				back_opacity: 1,
				back_roughness: 0.32,
				back_ior: 2,
				back_thickness: 0,
				back_attenuationColor: 0x8abd82,
				back_attenuationDistance: 0.155,
				back_specularIntensity: 1,
				back_specularColor: 0xffffff,
				child_types: "",
				models: "",
				mats: "",
				phone_color_mats: ""
			};
			camera, scene, renderer = setup_scene();

			function loader_func(){
				const hdrEquirect = new RGBELoader()
					.setPath( 'textures/equirectangular/' )
					// .load( 'field.hdr', function () {
					.load( 'indoor.hdr', function () {

						hdrEquirect.mapping = THREE.EquirectangularReflectionMapping;

						new GLTFLoader()
							.setPath( 'models/gltf/' )
							.load( 'iphone.glb', function ( gltf ) {

								gltf.scene.traverse( function ( child ) {
									const color = new THREE.Color();

									all_meshes.push(child.name);
									if ( child.isMesh){
										all_meshes.push(child.name);
										// Thinking about adding these back in, would like to try again, but this was causing some issues...
										/*
										child.castShadow = true;
										child.receiveShadow = true;
										*/
										all_mats.push(child.material.type)

										if (child.material.isMeshPhysicalMaterial) {
											// I am setting transmission to .01 in blender before my gltf export to force it to export pbr
											// Set it back to 0 here. I can turn it on per material where it makes sense 
											child.material.transmission = 0;
											// if (phone_color_mat_names.includes(child.name)){
											// 	phone_color_mats.push(child.material);
											// 	child.material.color.set( old_params.phone_color);

											// }
											// if (dir_metal_mat_names.includes(child.name)){
											// 	dir_metal_mats.push(child.material);
											// 	//metallic, roughness

											// }

											// if (child.name.includes("back")){
											// 	back_mat = child.material
											// 	back_mat.roughness = old_params.back_roughness;
											// 	// back_mat.metalness = old_params.metalness;
											// 	back_mat.ior = old_params.back_ior;
											// 	back_mat.opacity = old_params.back_opacity;
											// 	back_mat.specularIntensity = old_params.back_specularIntensity;
											// 	back_mat.transmission = old_params.back_transmission;
											// 	back_mat.thickness = old_params.back_thickness;
											// 	back_mat.attenuationColor.set( old_params.back_attenuationColor);
											// 	back_mat.attenuationDistance = old_params.back_attenuationDistance;


											// }
											if (child.name.includes("metal")){
											}
											if (child.name.includes("antenna")){
											}
											if (child.name.includes("dir_tex_metal")){
												console.log("dir_tex_metal")
												const tmp_mat = child.material; 
												mesh_mat_dict["dir_tex_metal"] =  tmp_mat;
												tmp_mat.color.setHex(mat_attrs["dir_tex_metal"].color);
												tmp_mat.roughness = mat_attrs["dir_tex_metal"].roughness;
												tmp_mat.metalness = mat_attrs["dir_tex_metal"].metalness;
												tmp_mat.ior = mat_attrs["dir_tex_metal"].ior;
												tmp_mat.transmission = mat_attrs["dir_tex_metal"].transmission;
												tmp_mat.thickness = mat_attrs["dir_tex_metal"].thickness;
												// THREE.GeometryUtils.tessellate( child, 3 )
												const tessellateModifier = new TessellateModifier( 8, 6 );

												// child = tessellateModifier.modify( child );


											}
											if (child.name.includes("glass")){
											}
											if (child.name.includes("lens")){
											}
											if (child.name.includes("shiny_black")){
											}
											if (child.name.includes("flash_cover")){
											}
											if (child.name.includes("grey_matte")){
											}










											// all_mats.push("child.material")
											// if (child.name.includes("glass")){

											// }

										}
									} 
								});
	
								
								init();
								all_models = gltf.scene;
								scene.add( gltf.scene );

								scene.environment = hdrEquirect;
								scene.background = hdrEquirect;
								scene.environmentIntensity = 1;
								scene.backgroundBlurriness = 1;


							} );


					} );
				}

			function some_stupid_func(){
				
			}

			loader_func();


			init();
			animate();


			function init() {

				// Lights
				hemi_light, dir_light = create_lights();

				///// Debug Geom /////
				// material = new THREE.MeshPhongMaterial();
				// geometry = new THREE.BoxGeometry( 0.01, 0.01, 0.01 );
				// mesh = new THREE.Mesh( geometry, material );
				// scene.add( mesh );
				//////////////////////

				// controls
				const controls = new OrbitControls( camera, renderer.domElement );

				// post-processing
				ssao_pass();
				create_gui();

				window.addEventListener( 'resize', onWindowResize );
				window.addEventListener( 'beforeunload', window_refresh );

			}

			function window_refresh(){
				save_data();
			};

			function save_data(){
			// let old_params_out = JSON.stringify(params);
			// console.log(params_out);
			var blob_data = new Blob([JSON.stringify( mat_attrs, null, 2)], {type: 'data:text/json;charset=utf-8'});
			console.log(saveAs(blob_data, "saved_data.json"));

			Cookies.remove("material_attributes");
			Cookies.set("material_attributes", JSON.stringify( mat_attrs, null, 2), { expires: 365 });

			}

			function onWindowResize() {

			camera.aspect = window.innerWidth / window.innerHeight;
			camera.updateProjectionMatrix();

			renderer.setSize( window.innerWidth, window.innerHeight );
			// renderer.setPixelRatio( window.devicePixelRatio );	

			}
			function dummy(){

			}

			function animate() {

				requestAnimationFrame( animate );
				renderer.render( scene, camera );
				render();

			}
			function render() {

				composer.render();

				}
			
			// helper funcs
			function setup_scene() {

				// Camera
				camera = new THREE.PerspectiveCamera( 20, window.innerWidth / window.innerHeight, 0.001, 1000 );
				camera.position.set(.3, .3, -.3);

				// Renderer
				renderer = new THREE.WebGLRenderer({antialias : true});
				renderer.setPixelRatio( window.devicePixelRatio );	
				renderer.setSize(window.innerWidth, window.innerHeight);
				renderer.shadowMap.enabled = true;
				renderer.shadowMap.type = THREE.PCFSoftShadowMap;
				renderer.setClearColor(0xFEFEFE);

				document.body.appendChild(renderer.domElement);

				// Scene
				scene = new THREE.Scene();

				return camera, scene, renderer;
			}

			function create_lights() {
				// Lights
				const hemi_light = new THREE.HemisphereLight( 0xffffff, 0xbbbbff, 1 );
				scene.add( hemi_light );

				const dir_light = new THREE.SpotLight( 0xffffff, 2.0 );
				dir_light.position.set( 1, 1, 1);
				dir_light.castShadow = true;
				dir_light.shadow.mapSize.set(2048,2048);
				dir_light.shadow.intensity = 1;
				const d = 10;

				dir_light.shadow.camera.left = - d;
				dir_light.shadow.camera.right = d;
				dir_light.shadow.camera.top = d;
				dir_light.shadow.camera.bottom = - d;
				dir_light.shadow.camera.far = 2;
				dir_light.shadow.camera.near = .01;

				dir_light.shadow.normalBias = 0.01;
				dir_light.shadow.bias = 0.0001;

				dir_light.shadow.intensity = 1;
				dir_light.shadow.radius = 10;
				// scene.add( new THREE.CameraHelper( dir_light.shadow.camera ) );

				scene.add(dir_light);
				return hemi_light, dir_light
			}

			function ssao_pass() {
				composer = new EffectComposer( renderer );
				renderPass = new RenderPass( scene, camera );
				composer.addPass( renderPass );
				saoPass = new SAOPass( scene, camera );
				composer.addPass( saoPass );
				const outputPass = new OutputPass();
				composer.addPass( outputPass );

				saoPass.params.saoIntensity = .1;
				saoPass.params.saoScale = 70;
				saoPass.params.saoKernelRadius = 100;
				saoPass.params.saoBlurRadius = 5;
				saoPass.enabled = true;
			}
			function log_data(){
				const tmp_blob = new Blob([JSON.stringify( mat_attrs)], {type: 'data:text/json;charset=utf-8'});
				console.log(JSON.stringify(tmp_blob.text()));
			}

			function inspect_methods(object_to_inspect){
				console.log(Object.getOwnPropertyNames(object_to_inspect).filter(function (p) {
					return typeof object_to_inspect[p] === 'function';
				}));

			}
			function create_gui(){
	
				// gui
				const gui = new GUI();

				const back_folde = gui.addFolder("back");
				back_folde.add( old_params, 'models' ).options( all_meshes ).onChange(dummy);
				back_folde.add( old_params, 'mats' ).options( all_mats ).onChange(dummy);
				back_folde.add( old_params, 'phone_color_mats' ).options( phone_color_mats ).onChange(dummy);

				///////////////////////////////////////////////////////////////////////////////////
				///////////// Loop through all dictionary entries and create gui //////////////////
				///////////////////////////////////////////////////////////////////////////////////

				for (const [key, value] of Object.entries( mat_attrs)) {

					// Not necessary but makes things more readable
					let folder = gui_tabs;
					let material = mesh_mat_dict;
					let params =  mat_attrs;

					// Folder
					folder[key] = gui.addFolder(key);

					// Color
					folder[key].addColor(  params[key], 'color' )
						.onChange(function () 
						{
							material[key].color.set( params[key].color );
							render();
						} );
						
					// "metalness": 0,
					folder[key].add( params[key], 'metalness', 0, 1, 0.01 )
					.onChange( function () {
						material[key].metalness = params[key].metalness;

						render();
					} );

					// "roughness": 0.5,
					folder[key].add( params[key], 'roughness', 0, 1, 0.01 )
					.onChange( function () {
						material[key].roughness = params[key].roughness;
						render();
					} );

					// "ior": 1.5,
					folder[key].add( params[key], 'ior', 0, 2, 0.01 )
					.onChange( function () {
						material[key].ior = params[key].ior;
						render();
					} );

					// "thickness": 0.01,
					folder[key].add( params[key], 'thickness', 0, 5, 0.01 )
					.onChange( function () {
						material[key].thickness = params[key].thickness;
						render();
					} );

					// "transmission": 0
					folder[key].add( params[key], 'transmission', 0, 1, 0.01 )
					.onChange( function () {
						material[key].transmission = params[key].transmission;
						render();
					} );

					folder[key].close();

					// Open a folder you would like the user to focus on by default
					if (key.includes("dir_tex_metal")){
						// folder[key].open();
						inspect_methods(folder[key])
						console.log("CLOSED " + folder[key]._closed)

						// folder[key].onChange( function () {console.log("I AM CHANGING");
						// } );
					}



					
				}



				back_folde.addColor( old_params, 'phone_color' )
					.onChange( function () {
						phone_color_mats.forEach(mat => {
							mat.color.set( old_params.phone_color );
							render();
							});
						});

				
				back_folde.add( old_params, 'back_transmission', 0, 1, 0.01 )
					.onChange( function () {

						back_mat.transmission = old_params.back_transmission;
						render();

					} );


				back_folde.add( old_params, 'back_roughness', 0, 1, 0.01 )
					.onChange( function () {

						back_mat.roughness = old_params.back_roughness;
						render();

					} );

				back_folde.add( old_params, 'back_ior', 1, 2, 0.01 )
					.onChange( function () {

						back_mat.ior = old_params.back_ior;
						render();

					} );

				back_folde.add( old_params, 'back_opacity', 0, 1, 0.01 )
					.onChange( function () {

						back_mat.opacity = old_params.back_opacity;
						const transparent = old_params.back_opacity < 1;

						if ( transparent !== back_mat.transparent ) {

							back_mat.transparent = transparent;
							back_mat.needsUpdate = true;

						}

						render();

					} );

				back_folde.add( old_params, 'back_thickness', 0, 5, 0.01 )
					.onChange( function () {

						back_mat.thickness = old_params.back_thickness;
						render();

					} );

				back_folde.addColor( old_params, 'back_attenuationColor' )
					.name( 'attenuation color' )
					.onChange( function () {

						back_mat.attenuationColor.set( old_params.back_attenuationColor );
						render();

					} );

				back_folde.add( old_params, 'back_attenuationDistance', 0, 10, 0.01 )
					.onChange( function () {

						back_mat.attenuationDistance = old_params.back_attenuationDistance;
						render();

					} );

				back_folde.add( old_params, 'back_specularIntensity', 0, 1, 0.01 )
					.onChange( function () {

						back_mat.specularIntensity = old_params.back_specularIntensity;
						render();

					} );

				back_folde.addColor( old_params, 'back_specularColor' )
					.onChange( function () {

						back_mat.specularColor.set( old_params.back_specularColor );
						render();

					} );

				back_folde.close();
				gui.open();


			}
		</script>

	</body>
</html>
