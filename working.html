<!DOCTYPE html>
<html lang="en">
	<head>
		<title>Apple iPhone 15</title>
		<meta charset="utf-8">
		<meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">
		<link type="text/css" rel="stylesheet" href="main.css">


	</head>
	<body>

		<!-- <div id="info" class="parent">iPhone 15 -->
		<img id="apple" src = "svg/apple.svg"  class="parent" alt=""/>
			<div id="info" class="parent">iPhone 15

			<div id="tag" class="child"> A virtual tour. </div>

		</img>

		<script type="importmap">
			{
				"imports": {
					"three": "../build/three.module.js",
					"three/addons/": "./jsm/"
				}
			}
		</script>

		<script type="module">

			import * as THREE from 'three';

			import {Â OrbitControls } from 'three/addons/controls/OrbitControls.js';
			import { RGBELoader } from 'three/addons/loaders/RGBELoader.js';
			import { GLTFLoader } from 'three/addons/loaders/GLTFLoader.js';
			import { TessellateModifier } from 'three/addons/modifiers/TessellateModifier.js';


			// Post Processing
			import { EffectComposer } from 'three/addons/postprocessing/EffectComposer.js';
			import { RenderPass } from 'three/addons/postprocessing/RenderPass.js';
			import { SAOPass } from 'three/addons/postprocessing/SAOPass.js';
			import { OutputPass } from 'three/addons/postprocessing/OutputPass.js';
			
			// Gui
			import { GUI } from 'three/addons/libs/lil-gui.module.min.js';

			// Save/load files/cookies
			import { saveAs } from 'file-saver';
			import {  gui_map } from './gui_defaults.js';
			import Cookies from 'js-cookie';
			// import { camera_zoom } from 'camera_utils.js';


			// Cookie
			let save_cookies = true;

			// Camera
			let camera_pos, camera_rot, camera_target, camera_zoom
			let cookie_cam_pos, cookie_cam_rot, cookie_cam_target, cookie_cam_zoom;
			camera_pos = [.3, .3, -.3];
			camera_rot =  [ -2.4, 0.615, 2.617 ];
			camera_target =  [ 0, 0, 0 ];
			camera_zoom = 1;
			let scene_controls = {
					"background_color": new THREE.Color(0xF5F5F7),
					"light_intensity": 1,
				}


			// Material
			let mat_attrs,  cookie_mat_attrs;
			mat_attrs = gui_map;

			
			var camera, scene, renderer, controls ;
			var geometry, material, mesh, all_models, gltf_meshes;

			//ssao
			let composer, renderPass, saoPass,container, stats, hemi_light, dir_light;
			let screen_mat, back_mat, antenna_mat, glass_mat, lens_mat, shiny_black_mat, tex_metal_mat, flash_cover_mat, dir_tex_metal_mat, metal_mat, grey_matte_mat;
			let all_meshes = [];
			let all_mats = [];
			let all_mat_names = [
									"screen_mat",
									"back_mat", 
									"antenna_mat",
									"glass_mat",
									"lens_mat",
									"shiny_black_mat",
									"tex_metal_mat",
									"flash_cover_mat",
									"dir_tex_metal_mat",
									"metal_mat",
									"grey_matte_mat"
								];

			let phone_color_mat_names = [
									"back", 

									"antenna",
									"dir_tex_metal",
									"tex_metal",

								  ];
			let phone_color_mats = [];

			let dir_metal_mat_names = [
										"tex_metal",
										"dir_tex_metal",
									  ];
			let dir_metal_mats = [];

			const dummy_mat = new THREE.MeshPhysicalMaterial();

			let screen_tab,
				back_tab,
				antenna_tab,
				glass_tab,
				lens_tab,
				shiny_black_tab,
				reg_tex_metal_tab,
				flash_cover_tab,
				dir_tex_metal_tab,
				metal_tab,
				grey_matte_tab,
				black_matte_tab,
				backing_matte_tab,
				blocker_matte_tab

			let gui_tabs= {
							"screen" : screen_tab,
							"back" : back_tab,
							"antenna" : antenna_tab,
							"dir_tex_metal" : dir_tex_metal_tab,
							"shiny_metal" : metal_tab,
							"reg_tex_metal" : reg_tex_metal_tab,
							"glass" : glass_tab,
							"lens" : lens_tab,
							"shiny_black" : shiny_black_tab,
							"flash_cover" : flash_cover_tab,
							"grey_matte" : grey_matte_tab,
							"black_matte" : black_matte_tab,
							"backing_matte" : backing_matte_tab,
							"blocker_matte" : blocker_matte_tab,
							}

			let mesh_mat_dict = {
								"screen" : dummy_mat,
								"back" : dummy_mat,
								"antenna" : dummy_mat,
								"dir_tex_metal" : dummy_mat,
								"shiny_metal" : dummy_mat,
								"reg_tex_metal" : dummy_mat,
								"glass" : dummy_mat,
								"lens" : dummy_mat,
								"shiny_black" : dummy_mat,
								"flash_cover" : dummy_mat,
								"grey_matte" : dummy_mat,
								"black_matte" : dummy_mat,
								"backing_matte" : dummy_mat,
								"blocker_matte" : dummy_mat,
								}

			const old_params = {
				color: 0xffffff,
				phone_color: 0x8abd82,

				dir_metalness:1,
				dir_roughness:.5,

				metal_color: 0xc0c0c0,
				metal_metalness:1,
				metal_roughness:.5,


				back_transm: 1,
				back_roughness: 0,
				back_ior: 1.5,
				back_thickness: 0.01,

				glass_color:0xc0c0c0,
				glass_transm: 0,

				back_transmission: 1,
				back_opacity: 1,
				back_roughness: 0.32,
				back_ior: 2,
				back_thickness: 0,
				back_attenuationColor: 0x8abd82,
				back_attenuationDistance: 0.155,
				back_specularIntensity: 1,
				back_specularColor: 0xffffff,
				child_types: "",
				models: "",
				mats: "",
				phone_color_mats: ""
			};

			load_cookies();
			init_scene();


			init_loader();
			init();
			animate();

			debug_camera();

			function init() {

				// Lights
				hemi_light, dir_light = create_lights();

				///// Debug Geom /////
				// material = new THREE.MeshPhongMaterial();
				// geometry = new THREE.BoxGeometry( 0.01, 0.01, 0.01 );
				// mesh = new THREE.Mesh( geometry, material );
				// scene.add( mesh );
				//////////////////////

				// controls
				controls = new OrbitControls( camera, renderer.domElement );
				controls.target.x = camera_target[0];
				controls.target.y = camera_target[1];
				controls.target.z = camera_target[2];
				controls.update()
				// post-processing
				ssao_pass();
				create_gui();

				window.addEventListener( 'resize', onWindowResize );
				window.addEventListener( 'beforeunload', window_refresh );

			}

			function window_refresh(){
				save_data();
			};


			function onWindowResize() {
				camera.aspect = window.innerWidth / window.innerHeight;
				camera.updateProjectionMatrix();
				renderer.setSize( window.innerWidth, window.innerHeight );
				// renderer.setPixelRatio( window.devicePixelRatio );	
			}
			function dummy(){

			}

			function animate() {
				requestAnimationFrame( animate );
				renderer.render( scene, camera );
				// controls.update();
				render();
			}

			function render() {
				composer.render();
				}
			
			function load_cookies(){
				////////////
				// Camera //
				////////////
				try {
					cookie_cam_pos = JSON.parse(Cookies.get("camera_position"));
					cookie_cam_rot = JSON.parse(Cookies.get("camera_rotation"));
					cookie_cam_target = JSON.parse(Cookies.get("camera_target"));
					cookie_cam_zoom = JSON.parse(Cookies.get("camera_zoom"));
					console.log("cookie_cam_target  ", cookie_cam_target)
				}catch (error) {
					console.log("Camera position has not been found, it will not be loaded");
				}
				if ( cookie_cam_pos instanceof Object) {
					camera_pos =  cookie_cam_pos;
					camera_rot =  cookie_cam_rot;
					camera_target =  cookie_cam_target;
					console.log("camera_target ", camera_target);

					console.log("Camera position has been found, now loading");
				}
				//////////////
				// Material //
				//////////////
				try {
					cookie_mat_attrs = JSON.parse(Cookies.get("material_attributes"));
				}catch (error) {
					console.log("Material attributes have not been found, they will not be loaded");
				}
				// If dictionary is valid use it, otherwise use the one from gui_defaults.js
				if ( cookie_mat_attrs instanceof Object) {
					mat_attrs =  cookie_mat_attrs;
					console.log("Material_attributes have been found, now loading");
				}
				//////////////
				// scene_controls //
				//////////////

				let cookie_scene_controls;
				try {
					cookie_scene_controls = JSON.parse(Cookies.get("scene_controls"));
				}catch (error) {
					console.log("Scene Controls have not been found, they will not be loaded");
				}
				// If dictionary is valid use it, otherwise use the one from gui_defaults.js
				if ( cookie_scene_controls instanceof Object) {
					scene_controls =  cookie_scene_controls;
					console.log("Scene Controls have been found, now loading");
				}
				// let scene_controls = {
				// 	"background_color": new THREE.Color(0xF5F5F7),
				// 	"light_intensity": 1,
				// }




			}

			function init_loader(){
				const hdrEquirect = new RGBELoader()
					.setPath( 'textures/equirectangular/' )
					// .load( 'field.hdr', function () {
					.load( 'indoor_grey.hdr', function () {

						hdrEquirect.mapping = THREE.EquirectangularReflectionMapping;

						new GLTFLoader()
							.setPath( 'models/gltf/' )
							.load( 'iphone.glb', function ( gltf ) {

								gltf.scene.traverse( function ( child ) {
									const color = new THREE.Color();

									all_meshes.push(child.name);
									if ( child.isMesh){
										all_meshes.push(child.name);
										// Thinking about adding these back in, would like to try again, but this was causing some issues...
										/*
										child.castShadow = true;
										child.receiveShadow = true;
										*/
										all_mats.push(child.material.type)

										if (child.material.isMeshPhysicalMaterial) {
											// I am setting transmission to .01 in blender before my gltf export to force it to export pbr
											// Set it back to 0 here. I can turn it on per material where it makes sense 
											child.material.transmission = 0;
											for (const [key, value] of Object.entries( mat_attrs)) {
												if (child.name.includes(key)){
													console.log(key)
													const tmp_mat = child.material; 
													mesh_mat_dict[key] =  tmp_mat;
													tmp_mat.color.setHex(mat_attrs[key].color);
													tmp_mat.roughness = mat_attrs[key].roughness;
													tmp_mat.metalness = mat_attrs[key].metalness;
													tmp_mat.ior = mat_attrs[key].ior;
													tmp_mat.transmission = mat_attrs[key].transmission;
													tmp_mat.thickness = mat_attrs[key].thickness;
													// Might use these again in the future, but for now I don't think I need them
													// tmp_mat.opacity = mat_attrs[key].opacity;
													// tmp_mat.specularColor = mat_attrs[key].specularColor;
													// tmp_mat.specularIntensity = mat_attrs[key].specularIntensity;
													// tmp_mat.attenuationColor.set( mat_attrs[key].attenuationColor);
													// tmp_mat.attenuationDistance = mat_attrs[key].attenuationDistance;
												}
											}

											// if (child.name.includes("metal")){
											// }
											// if (child.name.includes("antenna")){
											// }
											// if (child.name.includes("dir_tex_metal")){
											// 	console.log("dir_tex_metal")
											// 	const tmp_mat = child.material; 
											// 	mesh_mat_dict["dir_tex_metal"] =  tmp_mat;
											// 	tmp_mat.color.setHex(mat_attrs["dir_tex_metal"].color);
											// 	tmp_mat.roughness = mat_attrs["dir_tex_metal"].roughness;
											// 	tmp_mat.metalness = mat_attrs["dir_tex_metal"].metalness;
											// 	tmp_mat.ior = mat_attrs["dir_tex_metal"].ior;
											// 	tmp_mat.transmission = mat_attrs["dir_tex_metal"].transmission;
											// 	tmp_mat.thickness = mat_attrs["dir_tex_metal"].thickness;

											// 	// Might use these again in the future, but for now I don't think I need them
											// 	// tmp_mat.opacity = mat_attrs["dir_tex_metal"].opacity;
											// 	// tmp_mat.specularColor = mat_attrs["dir_tex_metal"].specularColor;
											// 	// tmp_mat.specularIntensity = mat_attrs["dir_tex_metal"].specularIntensity;
											// 	// tmp_mat.attenuationColor.set( mat_attrs["dir_tex_metal"].attenuationColor);
											// 	// tmp_mat.attenuationDistance = mat_attrs["dir_tex_metal"].attenuationDistance;


											// }
											// if (child.name.includes("glass")){
											// }
											// if (child.name.includes("lens")){
											// }
											// if (child.name.includes("shiny_black")){
											// }
											// if (child.name.includes("flash_cover")){
											// }
											// if (child.name.includes("grey_matte")){
											// }










											// all_mats.push("child.material")
											// if (child.name.includes("glass")){

											// }

										}
									} 
								});
	
								
								init();
								all_models = gltf.scene;
								scene.add( gltf.scene );

								scene.environment = hdrEquirect;
								// scene.background = hdrEquirect;
								scene.environmentIntensity = scene_controls.light_intensity;
								scene.backgroundBlurriness = 1;
								renderer.setClearColor(scene_controls.background_color);



							} );


					} );
				}
			


			// helper funcs
			function init_scene() {
				// Camera
				camera = new THREE.PerspectiveCamera( 20, window.innerWidth / window.innerHeight, 0.001, 1000 );
				camera.position.set(camera_pos[0], camera_pos[1], camera_pos[2]);
				camera.rotation.set(camera_rot[0], camera_rot[1], camera_rot[2]);
				console.log("INITIAL CAMERA TARGET POSITION ", camera_target[0], camera_target[1], camera_target[2]);
				// camera.lookAt(camera_target[0], camera_target[1], camera_target[2]);
				camera.lookAt(0, 0, 0);
				camera.zoom = camera_zoom;
				// camera.lookAt(),
				camera.autoRotate = true;

				// Renderer
				renderer = new THREE.WebGLRenderer({antialias : true});
				renderer.setPixelRatio( window.devicePixelRatio );	
				renderer.setSize(window.innerWidth, window.innerHeight);
				renderer.shadowMap.enabled = true;
				renderer.shadowMap.type = THREE.PCFSoftShadowMap;
				renderer.setClearColor(0xFEFEFE);
				document.body.appendChild(renderer.domElement);
				// accommodate CSS table
				renderer.domElement.style.position = 'absolute';
				renderer.domElement.style.top = 1;

				// Scene
				scene = new THREE.Scene();

				// return camera, scene, renderer;
			}

			function create_lights() {
				// Lights
				const hemi_light = new THREE.HemisphereLight( 0xffffff, 0xbbbbff, 1 );
				scene.add( hemi_light );

				const dir_light = new THREE.SpotLight( 0xffffff, 2.0 );
				dir_light.position.set( 1, 1, 1);
				dir_light.castShadow = true;
				dir_light.shadow.mapSize.set(2048,2048);
				dir_light.shadow.intensity = 1;
				const d = 10;

				dir_light.shadow.camera.left = - d;
				dir_light.shadow.camera.right = d;
				dir_light.shadow.camera.top = d;
				dir_light.shadow.camera.bottom = - d;
				dir_light.shadow.camera.far = 2;
				dir_light.shadow.camera.near = .01;

				dir_light.shadow.normalBias = 0.01;
				dir_light.shadow.bias = 0.0001;

				dir_light.shadow.intensity = 1;
				dir_light.shadow.radius = 10;
				// scene.add( new THREE.CameraHelper( dir_light.shadow.camera ) );

				scene.add(dir_light);
				return hemi_light, dir_light
			}

			function ssao_pass() {
				composer = new EffectComposer( renderer );
				renderPass = new RenderPass( scene, camera );
				composer.addPass( renderPass );
				saoPass = new SAOPass( scene, camera );
				composer.addPass( saoPass );
				const outputPass = new OutputPass();
				composer.addPass( outputPass );

				saoPass.params.saoIntensity = .1;
				saoPass.params.saoScale = 70;
				saoPass.params.saoKernelRadius = 100;
				saoPass.params.saoBlurRadius = 5;
				saoPass.enabled = true;
			}
			function log_data(){
				const tmp_blob = new Blob([JSON.stringify( mat_attrs)], {type: 'data:text/json;charset=utf-8'});
				console.log(JSON.stringify(tmp_blob.text()));
			}

			function inspect_methods(object_to_inspect){
				console.log(Object.getOwnPropertyNames(object_to_inspect).filter(function (p) {
					return typeof object_to_inspect[p] === 'function';
				}));

			}
			function get_camera_pos(){
				// Position
				const Tx = camera.position.x;
				const Ty = camera.position.y;
				const Tz = camera.position.z;

				// Rotation
				const Rx = camera.rotation.x;
				const Ry = camera.rotation.y;
				const Rz = camera.rotation.z;

				// Target
				const Ttx = controls.target.x;
				const Tty = controls.target.y;
				const Ttz = controls.target.z;

				// Zoom
				const Zm = camera.zoom;


				// const tmp_pos = camera.position;
				camera_pos = [Tx, Ty, Tz];
				camera_rot = [Rx, Ry, Rz];
				camera_target = [Ttx, Tty, Ttz];
				camera_zoom = Zm;
				// localStorage.setItem("camera.position.x", camera.position.x.toString())
				// localStorage.setItem("camera.position.y", camera.position.y.toString())
				// localStorage.setItem("camera.position.z", camera.position.z.toString())
				// localStorage.setItem("camera.rotation.x", camera.rotation.x.toString())
				// localStorage.setItem("camera.rotation.y", camera.rotation.y.toString())
				// localStorage.setItem("camera.rotation.z", camera.rotation.z.toString())
				// localStorage.setItem("camera.zoom", camera.zoom.toString())

				
			};

			function save_data(){

				if (save_cookies){
					get_camera_pos();
					flush_cookies();


					Cookies.set("scene_controls", JSON.stringify( scene_controls, null, 2), { expires: 365 });

					
					// Camera //
					// --pos
					Cookies.set("camera_position", JSON.stringify( camera_pos, null, 2), { expires: 365 });
					// --rot
					Cookies.set("camera_rotation", JSON.stringify( camera_rot, null, 2), { expires: 365 });
					// --target
					Cookies.set("camera_target", JSON.stringify( camera_target, null, 2), { expires: 365 });

					// --zoom
					Cookies.set("camera_zoom", JSON.stringify( camera_zoom, null, 2), { expires: 365 });

					// Material Attrs
					Cookies.set("material_attributes", JSON.stringify( mat_attrs, null, 2), { expires: 365 });
				}
				
			}

			function flush_cookies(){
				Cookies.remove("scene_controls");
				Cookies.remove("camera_position");
				Cookies.remove("camera_rotation");
				Cookies.remove("camera_target");
				Cookies.remove("camera_zoom");
				Cookies.remove("material_attributes");
			}

			function reload_no_save(){
				save_json();
				flush_cookies();
				save_cookies = false;
				location.reload();

			}

			function debug_camera(){
					get_camera_pos();
					console.log("CAMERA POSITION ", camera_pos)
					console.log("CAMERA ROTATION ", camera_rot)
					console.log("CAMERA ZOOM ", camera_zoom)
					console.log("CONTROLS TARGET ", camera_target)
					
				}

			function reset_camera(){
				const pos = [.3, .3, -.3];
				const rot = [-2.4, 0.615, 2.617 ];
				// camera_rot =  [ -2.4, 0.615, 2.617 ];
				// camera_zoom = 1;

				camera.position.set(pos[0], pos[1], pos[2]);
				camera.rotation.set(0, 0, 0);
				camera.zoom = 1
				controls.target.x = 0;
				controls.target.y = 0;
				controls.target.z = 0;
				controls.update();
				location.reload();
				// camera.rotation.set(camera_rot[0], camera_rot[1], camera_rot[2]);
				// camera.zoom = camera_zoom;

			}
			function reset_focus(){
				const pos = [.3, .3, -.3];
				const rot = [-2.4, 0.615, 2.617 ];
				// camera_rot =  [ -2.4, 0.615, 2.617 ];
				// camera_zoom = 1;

				// camera.position.set(pos[0], pos[1], pos[2]);
				// camera.position.x = .3;
				// camera.position.z = -.3;
				// camera.position.z = 0;
				// camera.rotation.x = -2.4;
				// camera.rotation.y = 0.615;
				// camera.rotation.z = 2.617;
				// camera.zoom = 1
				controls.target.x = 0;
				controls.target.z = 0;
				camera.lookAt(0,camera_pos.y,0)
				// controls.target.y = camera_pos[1];
				// controls.target.z = 0;
				controls.update();
				// camera.rotation.set(camera_rot[0], camera_rot[1], camera_rot[2]);
				// camera.zoom = camera_zoom;

			}

			function save_json(){
				get_camera_pos();
				var blob_data = new Blob([ JSON.stringify( camera_pos, null, 3),
										   JSON.stringify( camera_target, null, 3),
										   JSON.stringify( mat_attrs, null, 2),],
										   {type: 'data:text/json;charset=utf-8'});
				console.log(saveAs(blob_data, "saved_data.json"));

			}
			function set_light_intensity(intensity = 1){
				scene.environmentIntensity = intensity;

			}
			function set_background(intensity = 1){
				renderer.setClearColor(0xC9C9C9);

			}




			function create_gui(){
	
				// gui
				const gui = new GUI();

				///////////////////////////////////////
				//////////// debug button /////////////
				///////////////////////////////////////
				const buttons = {
					"debug stats": debug_camera,
					"reset camera": reset_camera,
					"reset focus": reset_focus,
					"dump stats": save_json,
					"flush cookies": reload_no_save,

					
				};


				gui.add( buttons, 'debug stats' );
				gui.add( buttons, 'reset camera' );
				gui.add( buttons, 'reset focus' );
				gui.add( buttons, 'dump stats' );
				gui.add( buttons, 'flush cookies' );
				///////////////////////////////////////






				gui.add( scene_controls, 'light_intensity', 0, 5, .01 )
					.onChange( function () {
						scene.environmentIntensity = scene_controls.light_intensity;
						render();
					} );

				gui.addColor( scene_controls, 'background_color' )
					.onChange( function () {
						renderer.setClearColor(scene_controls.background_color);
						render();
					});


				const back_folde = gui.addFolder("back");
				gui.add( old_params, 'models' ).options( all_meshes ).onChange(dummy);
				gui.add( old_params, 'mats' ).options( all_mats ).onChange(dummy);
				gui.add( old_params, 'phone_color_mats' ).options( phone_color_mats ).onChange(dummy);

				///////////////////////////////////////////////////////////////////////////////////
				///////////// Loop through all dictionary entries and create gui //////////////////
				///////////////////////////////////////////////////////////////////////////////////

				for (const [key, value] of Object.entries( mat_attrs)) {

					// Not necessary but makes things more readable
					let folder = gui_tabs;
					let material = mesh_mat_dict;
					let params =  mat_attrs;

					// Folder
					folder[key] = gui.addFolder(key);

					// Color
					folder[key].addColor(  params[key], 'color' )
						.onChange(function () 
						{
							material[key].color.set( params[key].color );
							render();
						} );
						
					// "metalness": 0,
					folder[key].add( params[key], 'metalness', 0, 1, 0.01 )
					.onChange( function () {
						material[key].metalness = params[key].metalness;

						render();
					} );

					// "roughness": 0.5,
					folder[key].add( params[key], 'roughness', 0, 1, 0.01 )
					.onChange( function () {
						material[key].roughness = params[key].roughness;
						render();
					} );

					// "ior": 1.5,
					folder[key].add( params[key], 'ior', 0, 2, 0.01 )
					.onChange( function () {
						material[key].ior = params[key].ior;
						render();
					} );

					// "thickness": 0.01,
					folder[key].add( params[key], 'thickness', 0, 5, 0.01 )
					.onChange( function () {
						material[key].thickness = params[key].thickness;
						render();
					} );

					// "transmission": 0
					folder[key].add( params[key], 'transmission', 0, 1, 0.01 )
					.onChange( function () {
						material[key].transmission = params[key].transmission;
						render();
					} );

					folder[key].close();

					// Open a folder you would like the user to focus on by default
					if (key.includes("dir_tex_metal")){
						// folder[key].open();
						inspect_methods(folder[key])
						console.log("CLOSED " + folder[key]._closed)

						// folder[key].onChange( function () {console.log("I AM CHANGING");
						// } );
					}



					
				}



				back_folde.addColor( old_params, 'phone_color' )
					.onChange( function () {
						phone_color_mats.forEach(mat => {
							mat.color.set( old_params.phone_color );
							render();
							});
						});

				
				back_folde.add( old_params, 'back_transmission', 0, 1, 0.01 )
					.onChange( function () {

						back_mat.transmission = old_params.back_transmission;
						render();

					} );


				back_folde.add( old_params, 'back_roughness', 0, 1, 0.01 )
					.onChange( function () {

						back_mat.roughness = old_params.back_roughness;
						render();

					} );

				back_folde.add( old_params, 'back_ior', 1, 2, 0.01 )
					.onChange( function () {

						back_mat.ior = old_params.back_ior;
						render();

					} );

				back_folde.add( old_params, 'back_opacity', 0, 1, 0.01 )
					.onChange( function () {

						back_mat.opacity = old_params.back_opacity;
						const transparent = old_params.back_opacity < 1;

						if ( transparent !== back_mat.transparent ) {

							back_mat.transparent = transparent;
							back_mat.needsUpdate = true;

						}

						render();

					} );

				back_folde.add( old_params, 'back_thickness', 0, 5, 0.01 )
					.onChange( function () {

						back_mat.thickness = old_params.back_thickness;
						render();

					} );

				back_folde.addColor( old_params, 'back_attenuationColor' )
					.name( 'attenuation color' )
					.onChange( function () {

						back_mat.attenuationColor.set( old_params.back_attenuationColor );
						render();

					} );

				back_folde.add( old_params, 'back_attenuationDistance', 0, 10, 0.01 )
					.onChange( function () {

						back_mat.attenuationDistance = old_params.back_attenuationDistance;
						render();

					} );

				back_folde.add( old_params, 'back_specularIntensity', 0, 1, 0.01 )
					.onChange( function () {

						back_mat.specularIntensity = old_params.back_specularIntensity;
						render();

					} );

				back_folde.addColor( old_params, 'back_specularColor' )
					.onChange( function () {

						back_mat.specularColor.set( old_params.back_specularColor );
						render();

					} );

				back_folde.close();
				gui.open();


			}
		</script>

	</body>
</html>
